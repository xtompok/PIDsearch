package pidsearch;

import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

/**
 * Class representing (partially) found connections tree.
 *
 * This class makes a tree structure, where the root is one Edge object from the
 * begining station and every other Arrival object in that tree referrences the
 * previous edge on the (partially) found connection. The tree should be sorted
 * chronologically, where every edge departure is later or equal the parent edge
 * arrival.
 *
 * @author jethro
 */
public class Arrival {

	/**
	 * Time of arrival to the edge.to station.
	 */
	public int arrival;
	/**
	 * Last edge on the path.
	 */
	public Edge edge;
	/**
	 * Referrence to the previous Arrival object on the path.
	 */
	public Arrival prev;

	/**
	 * Make a root Arrival object.
	 *
	 * This method makes root of Arrival tree. It must get an ConEdge as a
	 * parameter and the first arrival is the arrival to the end of the
	 * edge.
	 *
	 * @param edge First edge of all paths in the tree.
	 */
	public Arrival(ConEdge edge) {
		this.edge = edge;
		arrival = edge.departure + edge.length;
		prev = null;
	}

	/**
	 * Add a leaf to the Arrival tree.
	 *
	 * @param arr Referrence to the parent object.
	 * @param edge Edge to add to the Arrival tree.
	 */
	public Arrival(Arrival arr, ConEdge edge) {
		this.edge = edge;
		prev = arr;
		arrival = edge.departure + edge.length;
	}

	/**
	 * Add a leaf to the Arrival tree
	 *
	 * @param arr Referrence to the parent object.
	 * @param edge Edge to add to the Arrival tree.
	 * @param prefs SearchPreferences is needed when adding a WalkEdge,
	 * because time of transfer must be computed.
	 */
	public Arrival(Arrival arr, WalkEdge edge, SearchPreferences prefs) {
		this.edge = edge;
		prev = arr;
		this.arrival = arr.arrival + (edge.length / prefs.walkSpeed);
	}

	/**
	 * Make a List of Edges from one branch ending with this object.
	 *
	 * This method makes a List of Edges and adds into it last edge. Then
	 * goes up to the root of Arrival tree and adds Edge objects to the
	 * beginning of List. At the end, the List contains a branch of the
	 * Arrival tree ending in this object in order from root to this object.
	 *
	 * @return List of Edge from root to this object.
	 */
	public List<Edge> asList() {
		Arrival a;
		a = this;
		List<Edge> list;
		list = new LinkedList<Edge>();
		while (a != null) {
			list.add(0, a.edge);
			a = a.prev;
		}
		return list;
	}

	/**
	 * Standard equals implementation.
	 *
	 * This method checks, if given object is equal to this object. Two
	 * Arrivals are equal if they has equal last edge, equal arrival and if
	 * the path to the root is equal.
	 *
	 * @param object Object to compare to.
	 * @return true if objects are equal, false if not.
	 */
	@Override
	public boolean equals(Object object) {
		if (!(object instanceof Arrival)) {
			return false;
		}
		Arrival arr = (Arrival) object;
		if ((!this.edge.equals(arr.edge)) || !(this.arrival == arr.arrival)) {
			return false;
		}
		if (prev == arr.prev) {
			return true;
		}
		if ((prev == null) || (arr.prev == null)) {
			return false;
		}
		return prev.equals(arr.prev);
	}

	/**
	 * Generated HashCode implementation.
	 *
	 * This method generated by NetBeans computes a hashCode of the object.
	 *
	 * @return Hash code of the object.
	 */
	@Override
	public int hashCode() {
		int hash = 7;
		hash = 13 * hash + this.arrival;
		hash = 13 * hash + (this.edge != null ? this.edge.hashCode() : 0);
		hash = 13 * hash + (this.prev != null ? this.prev.hashCode() : 0);
		return hash;
	}
}

/** Comparator for the Arrival objects.
 * 
 * This class compares two Arrival objects according to arrival time chronologically.
 * 
 * @author Tomas Pokorny <xtompok@gmail.com>
 */

class ArrivalComparator implements Comparator<Arrival> {

	@Override
	public int compare(Arrival a1, Arrival a2) {
		return a1.arrival - a2.arrival;
	}
}
